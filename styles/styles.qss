from dataclasses import dataclass, field
from typing import Dict, Optional


@dataclass
class Spectrum:
    x: np.ndarray
    y: np.ndarray
    baseline: np.ndarray
    ycorr: np.ndarray
    meta: dict = field(default_factory=dict)


class DataStore:
    """Cache en mémoire des spectres chargés (clé = chemin fichier)."""
    def __init__(self):
        self._data: Dict[str, Spectrum] = {}
        self._mtimes: Dict[str, float] = {}

    def get(self, path: str) -> Optional[Spectrum]:
        return self._data.get(path)

    def set(self, path: str, spec: Spectrum, mtime: float):
        self._data[path] = spec
        self._mtimes[path] = mtime

    def ensure_fresh(self, path: str) -> bool:
        """Retourne True si présent et mtime inchangé, sinon False (à recharger)."""
        try:
            mtime = os.path.getmtime(path)
        except OSError:
            return False
        return path in self._data and self._mtimes.get(path) == mtime

    def invalidate(self, path: str):
        self._data.pop(path, None)
        self._mtimes.pop(path, None)


DATASTORE = DataStore()


def load_spectrum(path: str) -> Optional[Spectrum]:
    try:
        with open(path, "r", encoding="utf-8") as f:
            lines = f.readlines()
        header_idx = next((i for i, line in enumerate(lines) if line.strip().startswith("Pixel;")), 0)

        df = pd.read_csv(
            path,
            skiprows=header_idx,
            sep=";",
            decimal=",",
            encoding="utf-8",
            skipinitialspace=True,
            na_values=["", " ", "   ", "\t"],
            keep_default_na=True,
        )
        if df.columns[-1].startswith("Unnamed"):
            df = df.iloc[:, :-1]
        df.columns = [c.strip().replace("\xa0", " ") for c in df.columns]

        if not {"Raman Shift", "Dark Subtracted #1"}.issubset(df.columns):
            return None

        temp = df[["Raman Shift", "Dark Subtracted #1"]].copy()
        temp["Raman Shift"] = pd.to_numeric(temp["Raman Shift"], errors="coerce")
        temp["Dark Subtracted #1"] = pd.to_numeric(temp["Dark Subtracted #1"], errors="coerce")
        temp = temp.dropna(subset=["Raman Shift", "Dark Subtracted #1"])
        if temp.empty:
            return None

        x = temp["Raman Shift"].to_numpy()
        y = temp["Dark Subtracted #1"].to_numpy()
        order = np.argsort(x)
        x = x[order]
        y = y[order]

        try:
            baseline, _ = Baseline(x).modpoly(y, poly_order=5)
            ycorr = y - baseline
        except Exception:
            baseline = np.zeros_like(y)
            ycorr = y

        return Spectrum(x=x, y=y, baseline=baseline, ycorr=ycorr, meta={"path": path})
    except Exception:
        return None


    def plot_selected_with_baseline(self):
        files = getattr(self.file_picker, "selected_files", [])
        if not files:
            QMessageBox.information(self, "Info", "Aucun fichier sélectionné.")
            return

        traces = []
        for path in files:
            # recharger si absent ou si le fichier a changé
            if not DATASTORE.ensure_fresh(path):
                spec = load_spectrum(path)
                if spec is None:
                    # invalider au cas où il y avait une ancienne version
                    DATASTORE.invalidate(path)
                    continue
                try:
                    mtime = os.path.getmtime(path)
                except OSError:
                    mtime = 0.0
                DATASTORE.set(path, spec, mtime)

            spec = DATASTORE.get(path)
            if spec is None:
                continue

            name = os.path.basename(path)
            traces.append(
                go.Scatter(x=spec.x, y=spec.ycorr, name=f"{name}", mode="lines")
            )
            # Si un jour on souhaite afficher la baseline, décommentez ci-dessous
            # traces.append(
            #     go.Scatter(x=spec.x, y=spec.baseline, name=f"{name} – baseline", mode="lines", line=dict(dash="dash"))
            # )

        if not traces:
            QMessageBox.warning(self, "Erreur", "Aucun spectre valide n'a été trouvé dans la sélection.")
            return

        fig = go.Figure(traces)
        fig.update_layout(
            title="Spectres Raman",
            xaxis_title="Raman Shift (cm⁻¹)",
            yaxis_title="Intensité (a.u.)",
            width=1500,
            height=800,
        )
        self.plot_view.setHtml(fig.to_html(include_plotlyjs="cdn"))